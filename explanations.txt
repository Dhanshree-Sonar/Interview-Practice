Explanation for Interview Practice questions.

Question 1:
Given two strings s and t, determine whether some anagram of t is a substring of s. For example: if s = "udacity" and t = "ad", then the function returns True. Your function definition should look like: question1(s, t) and return a boolean True or False.

Clear the question:
- Will 's' be longer than 't'?
- Should we consider case sensitivity?

Confirm the input and output:
- Input: 2 strings. First is 's' and second is 't'.
- Output: Boolean

Discuss test cases:
- If any one of the parameters is not string then we can return Error.
- If length of the 't' is zero we can return True.
- If 's' is smaller than 't', we can return False.

Solution explanation:
- First of all we have to convert both the strings to similar case as we computing the result based on case insensitive characters.
- We have to scan 's' character by character. Each time we can grab the substring of 's'(starting at 'i'th position till the length of 't').
- We can compare sorted output of the substring and 't'. If it is true means we have the anagram of 't' in 's'.

Complexity:
- We are scanning 's' character by character so worst case runtime complexity is O(n) where n is the number of characters in 's'.
- We don't need other data structure to compute the result so the space complexity is O(1).


Question 2:
Given a string a, find the longest palindromic substring contained in a. Your function definition should look like question2(a), and return a string.

Clear the question:
- Is there a limit on string length?
- If we have more than one result, which one we should consider?
- Can we assume empty string or single character string as a palindromic string?

Confirm the input and output:
- Input: A string
- Output: Longest palindromic string

Discuss test cases:
- We should compute output case insensitively. "Racecar" can be considered as an palindromic string.
- If input is not a string then we can return error.
- If length is 0 or 1 then we can return the string as it is.
- If string contains no palindromic substring, which is longer than 1 character, then we can return first character of the string.
- If two palindromic substrings are of same size we can consider the first one as a longest palindromic substring.

Solution explanation:
- Convert a string to lower case to compute output case insensitively
- Start at the first character then from that character add one character at a time to form the substring and check if a substring is a palindromic.
- Compare the substring and its reversed string to check if the substring is palindromic or not
- If the string is palindromic then check if it is longer than the previous one. If it is then consider the current substring as a longest palindromic string.
- Move to the next character of the string and start checking for palindromic substring

Complexity:
- We are scanning 'a' character by character and each time we are checking m substrings where m is the length of the characters from 'i'th position. So the runtime complexity is approximately O(n^2).
- We need store a string in different variable which will less than or equal to the original string, so the space complexity is O(2) which can be approximated to O(1).


Question 3:
Given an undirected graph G, find the minimum spanning tree within G. A minimum spanning tree connects all vertices in a graph with the smallest possible total weight of edges. Your function should take in and return an adjacency list structured like this:

{'A': [('B', 2)],
 'B': [('A', 2), ('C', 5)],
 'C': [('B', 5)]}
Vertices are represented as unique strings. The function definition should be question3(G).

Clear the question:
- What if the graph is empty?
- What if the graph has a single node?

Confirm the input and output:
- Input: A Dictionary (Vertex as a key and Edges as values)
- Output: A Dictionary (Vertex as a key and Edges as values)

Discuss test cases:
- If the graph is an empty dictionary then we will return empty dictionary.
- If the graph has a single vertex then we will return Error.
- If the graph is not in a dictionary format we will return Error.

Solution explanation:
- Use Kruskal's algorithm (Greedy algorithm) to find the minimum spanning tree
- Find out unique edges and sort them by weight
- Take edges one by one and form a tree till all vertices are covered. Skip the edge if it is forming a cycle.
- One way to check if edge is forming a cycle in the graph is by keep track of each vertex in a list of sets. If the new edge will connect two vertices within the same set, we will not include it. Else, we union of the sets and pop other set.

Complexity:

- It will take O(E) time to create list of unique edges.
- We are using python sort function to sort the edges so the time complexity for that will be O(Elog(E)).
- We need to loop through each edges, find indexes and merge the vertices set to add edges to MST. This will take worst case O(E*V) time.
- It will take O(E) time to form the output.
- So, overall algorithm will take O(E + Elog(E) + E*V + E) which can be approximated to O(E*V).
- We need vertices set (V) and edges set (E) so the space complexity is O(E+V), also we need a dictionary to store output graph (G). So the space complexity is O(V+E+G).
